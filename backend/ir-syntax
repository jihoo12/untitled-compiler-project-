-common syntax 
a > b ## put a to b ,if no prefix (a = 64bit immediate value,b = 64bit register)
a == b ## compare a and b ,if no prefix then (a,b = 64bit register)
a-b ## assembly sub a,b ,if no prefix then (a,b = 64bit register)
a+b ## assembly add a,b ,if no prefix then (a,b = 64bit register)
a*b ## assembly mul a,b ,if no prefix then (a,b = 64bit register)
a/b ## assembly div a,b ,if no prefix then (a,b = 64bit register)
.a ## call a (a = 64bit address)
~a if carry flags set then jump a (a = 64bit address)
@ ## assembly ret
leave ## assembly leave
syscall ## assembly syscall
push a ## assembly push a 
pop b ## assembly pop b ,if no prefix then (b = 64bit register)
-
-prefix
m ## use memory address 
s ## use sib address 
i ## use immediate value 
r-i ## use register-immediate value(r-i = memory address)
r+i ## use register+immediate value(r+i = memory address)
r ## 64bit register prefix 
-
-usage
m i a > b ## a = 64bit address,b=64bit immediate value 
r r-i a > b ## a = 64bit register,b= 64bit register-immdate value (ex r r-i rax > rax-1)
s r base+(index*sclae)+displacement > b (ex s r rbx+(rcx*4)+8 > rax)
-
-notes
sib Effective Address=(Base)+(IndexÃ—Scale)+Displacement
-