---ir-syntax
--syntax
prefix command
-example
m,i a > b ## a = 64bit address,b=64bit immediate value 
r,r-i a > b ## a = 64bit register,b= 64bit register-immdate value (ex r r-i rax > rax-1)
s,r base+(index*sclae)+displacement > b (ex s r rbx+(rcx*4)+8 > rax)
--command
-arithmetic instructions
a-b ## assembly sub a,b ,if no prefix then (a,b = 64bit register)
a+b ## assembly add a,b ,if no prefix then (a,b = 64bit register)
a*b ## assembly mul a,b ,if no prefix then (a,b = 64bit register)
a/b ## assembly div a,b ,if no prefix then (a,b = 64bit register)
a & b ## assembly and a,b ,if no prefix then a,b = 64bit register 
a | b ## assembly or a,b ,if no prefix then a,b = 64bit register 
a ^ b ## assembly xor a,b ,if no prefix theb a,b = 64bit register 
~a ## assembly not a ,if no prefix a = 64bit register 
-unconditional jump instruction
.a ## call a (a = 64bit address)
-conditional branch instructions
a == b ## compare a and b ,if no prefix then (a,b = 64bit register)
=a ## if carry flags set then jump a (a = 64bit address)
!a ## if carry flags not set then jump a (a=64bit register)
-control flow instructions
enter ## assembly enter
@ ## assembly ret
leave ## assembly leave
syscall ## assembly syscall
-data transfer instructions
a > b ## put a to b ,if no prefix (a = 64bit register,b = 64bit register)
push a ## assembly push a 
pop b ## assembly pop b ,if no prefix then (b = 64bit register)
--prefix
m ## use memory address 
s ## use sib address 
i ## use immediate value 
r-i ## use 64bit register-immediate value(r-i = memory address)
r+i ## use 64bit register+immediate value(r+i = memory address)
r ## 64bit register prefix 
n ## no prefix use
--pland
JG
JA
JL
JB
JO
JNO
JS
JNS
JC
JNC
JZ
JNZ
shift
--notes
sib Effective Address=(Base)+(IndexÃ—Scale)+Displacement
---